#ifndef __YASTC_FINITEAUTOMATA__
#define __YASTC_FINITEAUTOMATA__
#include <vector>
#include <iostream>
#include <string>
#include <stack>
#include <set>
#include <map>
using namespace std;

class DFAFeeder{
public:
	DFAFeeder(const char* buffer, unsigned long length):_buffer(buffer), _length(length){ _curPos = 0;}
	char getNextChar(){return _buffer[_curPos++];}
	char peekNextChar(){return _buffer[_curPos];}
	bool hasNextChar(){if(_curPos >= _length) return false; return true;}
	void putBack(){if(_curPos > 0) _curPos--;}
	char getChar(unsigned long pos){return _buffer[pos];}
	unsigned long getPos(){return _curPos;}
private:
	const char* _buffer;
	unsigned long _length;
	unsigned long _curPos;
};

typedef int (*PFNDFAACTION)(int state, int character, int* nextState, void* pThis);

struct DFAState;
struct DFATransfer{
    int curState;
	char input;
    int nextState;
	PFNDFAACTION action;
};

class DFARunner{
public:
	DFARunner(DFAFeeder* feeder, void* userdata){_feeder = feeder; _transfers = 0;_otherTransfers = 0;_curState = 0;_userdata = userdata;}
	~DFARunner(){if(_transfers) delete[] _transfers;}
	void setTransferFunctions(const DFATransfer transfers[], int num, const DFATransfer otherTransfers[], int oNum);
	void init(int startState){_curState = startState;}

	int step();
	int getCurrentState(){return _curState;}
    int getPrevState(){return _prevState;}

protected:
	DFARunner(const DFARunner&){}

	DFAFeeder* _feeder;
	void* _userdata;

	DFATransfer* _transfers;
	int _transfersNum;
	DFATransfer* _otherTransfers;
	int _otherTransfersNum;

	int _curState;
    int _prevState;
};

struct DFAState{
    bool isTerminal;
    int  term_id;
};

struct Lexer{
	const DFATransfer* transfers;
	int num;
	const DFATransfer* otherTransfers;
	int oNum;

	int (*stateMap)[2];
	int mapNum;
};

const int FakeState = 0;

enum LexerAction{
	Accept = -1,
	Error = -2,
	FallBackAndAccept = -3,
	NeedToContinue = -4
};

struct Range{
	unsigned long start;
	unsigned long end;
	int tokenType;
};

struct Token{
	const char* token;
	int tokenType;
};

class LexerRunner : protected DFARunner{
public:
	LexerRunner(DFAFeeder* feeder):DFARunner(feeder, this){_curTokenPos = 0;DFARunner::init(FakeState);}
	void setLexer(Lexer* lexer);
    Token getNextToken();
    static int actionCheckFallback(int state, int character, int* nextState, void* pThis);
protected:
	void copyToken(const Range& range);
	Token rangeToToken(const Range& range);
	int stateToTokenType(int state);

	char _tokenBuffer[256];
	Range	_curToken;
	unsigned int _curTokenPos;
	vector<Range> _tokens;
	Lexer* _lexer;
};


class RegularExpression{
public:
    RegularExpression(const string & str){re_str = str;root = NULL;}
    ~RegularExpression(){if(root) recursiveDeleteTree(&root);}
    const string & toPostfix(){
        postfix_str = "";
        if(!buildTree())
            cout<<"Grammar Error"<<endl;
        calcPos(root);

        for(set<BinaryTreeNode*>::iterator it = root->firstpos.begin(); it != root->firstpos.end(); it++){
            (*it)->is_start_state = true;
        }

        for(set<BinaryTreeNode*>::iterator it = root->lastpos.begin(); it != root->lastpos.end(); it++){
            (*it)->is_term_state = true;
        }

        makeDFA();

        postOrder(root);
        return postfix_str;
    }

protected:
	struct BinaryTreeNode{
        BinaryTreeNode* leftChild;
        BinaryTreeNode* rightChild;
        char			character;

        bool            is_start_state;
        bool            is_term_state;
        int             term_id;

        bool                    nullable;
        set<BinaryTreeNode*>    firstpos;
        set<BinaryTreeNode*>    lastpos;
        set<BinaryTreeNode*>    followpos;
		
        BinaryTreeNode(){leftChild = rightChild = NULL;character = '\0';nullable = false;}
		BinaryTreeNode(BinaryTreeNode* left, BinaryTreeNode* right, char character){
            leftChild = left; rightChild = right; this->character = character;nullable = false;
		}
	};

    set<set<BinaryTreeNode* > > dstates_unsigned;
    set<set<BinaryTreeNode* > > dstates_signed;

    struct DTrans{
        set<BinaryTreeNode*>  from_state;
        char                  character;
        set<BinaryTreeNode*>  to_state;

        DTrans(const set<BinaryTreeNode*>& _from_state, char _character, const set<BinaryTreeNode*>& _to_state)
            :from_state(_from_state), character(_character), to_state(_to_state){}
    };
    vector<DTrans> dtrans;

    vector<set<BinaryTreeNode> *> state_map;

    BinaryTreeNode* buildTree();
    void recursiveDeleteTree(BinaryTreeNode **r);

    bool processOp(stack<BinaryTreeNode*>& op, stack<BinaryTreeNode*>& ch);
    void addOp(char c, stack<BinaryTreeNode*>& op, stack<BinaryTreeNode*>& ch);

    void calcPos(BinaryTreeNode* cur);
    void makeDFA();

    void postOrder(const BinaryTreeNode *TreeNode);

    bool is_op(char ch){return (ch == '|') || (ch == '.') || (ch == '*')|| (ch == '(')|| (ch == ')');}
    int get_op_pri(char ch){if(ch == '(') return -2;if(ch == ')') return -1; if(ch == '|') return 0; if(ch == '.') return 1; if(ch == '*')return 2; return 3;}
    int get_op_operandnum(char op){if(op == '|' || op == '.') return 2;return 1;}


    vector<BinaryTreeNode*> leafnodes;
	BinaryTreeNode* root;
	string re_str;
    string postfix_str;
};



#endif
