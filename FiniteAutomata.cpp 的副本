#include "FiniteAutomata.h"
#include <string.h>
#include <stack>
#include <algorithm>
using namespace std;

void DFARunner::setTransferFunctions(const DFATransfer transfers[], int num, const DFATransfer otherTransfers[], int oNum){
    if(_transfers)
        delete[] _transfers;
    if(_otherTransfers)
        delete[] _otherTransfers;

    _transfersNum = 0;
    _otherTransfersNum = 0;
    if(num > 0){
        _transfers = new DFATransfer[num];
        _transfersNum = num;
        memcpy(_transfers, transfers, num * sizeof(DFATransfer));
    }
    if(oNum > 0){
        _otherTransfers = new DFATransfer[oNum];
        _otherTransfersNum = oNum;
        memcpy(_otherTransfers, otherTransfers, oNum * sizeof(DFATransfer));
    }
}

int DFARunner::step(){
    int i, input;
    if(!_feeder->hasNextChar())
        return -1;
    input = _feeder->getNextChar();
    for(i = 0; i < _transfersNum; i++){
        if(_curState == _transfers[i].curState && input == _transfers[i].input){
            int prevState = _curState;
            _curState = _transfers[i].nextState;
            if(_transfers[i].action){
                int state = _transfers[i].action(prevState, input, &_curState, _userdata);
                switch(state){
                case FallBackAndAccept:
                    _feeder->putBack();
                case Accept:			//Fall through
                    return Accept;
                case Error:
                    return Error;
                }
            }
            return NeedToContinue;
        }
    }

    for(i = 0; i < _otherTransfersNum; i++){
        if(_curState == _otherTransfers[i].curState){
            int prevState = _curState;
            _curState = _otherTransfers[i].nextState;
            if(_otherTransfers[i].action){
                int state = _otherTransfers[i].action(prevState, input, &_curState, _userdata);
                switch(state){
                case FallBackAndAccept:
                    _feeder->putBack();
                case Accept:			//Fall through
                    return Accept;
                case Error:
                    return Error;
                }
            }
            return NeedToContinue;
        }
    }

    return Error;
}


Token LexerRunner::rangeToToken(const Range& range){
    Token t;
    copyToken(range);
    t.token = _tokenBuffer;
    t.tokenType = range.tokenType;
    return t;
}

void LexerRunner::copyToken(const Range& range){
    int i = 0;
    for(; i <= range.end - range.start; i++){
        _tokenBuffer[i] = _feeder->getChar(i + range.start);
    }
    _tokenBuffer[i] = '\0';
}

Token LexerRunner::getNextToken(){
    if(_curTokenPos < _tokens.size()){
        return rangeToToken(_tokens[_curTokenPos++]);
    }
    int state;
    Range newRange;
    newRange.start = (unsigned long)(-1);
    while(state = step()){
        switch(state){
        case Accept:
            newRange.end = _feeder->getPos() - 1;
            newRange.tokenType = stateToTokenType(state);
            _tokens.push_back(newRange);
            _curTokenPos++;
            DFARunner::init(FakeState);
            return rangeToToken(newRange);
            break;
        case NeedToContinue:
            if(state == NeedToContinue){
                int state2 = DFARunner::getCurrentState();
                if(state2 != FakeState && newRange.start == (unsigned long )-1)
                    newRange.start = _feeder->getPos() - 1;
            }
            break;
        case Error:
        default:
            break;
        }
    }

    Token t;
    t.token = NULL;
    return t;
}

int LexerRunner::actionAccept(int state, int character, int* nextState, void* pThis){
    LexerRunner* p = (LexerRunner*)pThis;
    return Accept;
}

int LexerRunner::actionFallBackAndAccept(int state, int character, int* nextState, void* pThis){
    LexerRunner* p = (LexerRunner*)pThis;
    return FallBackAndAccept;
}

int LexerRunner::stateToTokenType(int state){
    for(int i = 0; i < _lexer->mapNum; i++){
        if(_lexer->stateMap[0][i] == state){
            return _lexer->stateMap[1][i];
        }
    }
    return 0;
}

void LexerRunner::setLexer(Lexer* lexer){
    _lexer = lexer;
    DFARunner::setTransferFunctions(lexer->transfers, lexer->num, lexer->otherTransfers, lexer->oNum);
}

bool RegularExpression::processOp(stack<BinaryTreeNode*>& op, stack<BinaryTreeNode*>& ch){
    if(op.top()->character == '*'&& ch.size() > 0){
        BinaryTreeNode* node = op.top();
        op.pop();
        node->leftChild = ch.top();
        ch.pop();
        ch.push(node);
        return true;
    }else if((op.top()->character == '|' || op.top()->character == '.') && ch.size() > 1){
        BinaryTreeNode* node = op.top();
        op.pop();
        node->rightChild = ch.top();
        ch.pop();
        node->leftChild = ch.top();
        ch.pop();
        ch.push(node);
        return true;
    }else if(op.top()->character == '('){
        op.pop();
        return true;
    }
    return false;
}


RegularExpression::BinaryTreeNode* RegularExpression::buildTree(){
    stack<BinaryTreeNode*> op;
    stack<BinaryTreeNode*> ch;
    int start = 0;
    bool last_is_char = false;
    try{
        while(start < re_str.length()){
            char c = re_str[start];
            if(is_op(c)){
                if(c == '(' && last_is_char)
                    addOp('.', op, ch);
                addOp(c, op, ch);
                if(c == '(' || c == '|')
                    last_is_char = false;
                start++;
            }else{
                BinaryTreeNode* node;
                if(c == '\\'){
                    start++;
                    node = new BinaryTreeNode(0, 0, re_str[start]);
                }else{
                    node = new BinaryTreeNode(0, 0, c);
                }

                if(last_is_char == true){
                    addOp('.', op, ch);
                }
                ch.push(node);
                leafnodes.push_back(node);
                last_is_char = true;
                start++;
            }

        }
        while(op.size() > 0 && op.top()->character != '(' && processOp(op, ch));

        if(op.size() != 0 || ch.size() != 1){
            throw "";
        }

        op.push(new BinaryTreeNode(0, 0, '.'));
        BinaryTreeNode* n = new BinaryTreeNode(0, 0, '#');
        n->is_term_state = true;

        ch.push(n);
        processOp(op, ch);
    }catch(...){
        while(op.size() > 0){
            BinaryTreeNode* node = op.top();
            recursiveDeleteTree(&node);
            op.pop();
        }
        while(ch.size() > 0){
            BinaryTreeNode* node = ch.top();
            recursiveDeleteTree(&node);
            ch.pop();
        }
        return NULL;
    }

    root = ch.top();
    return root;
}

void RegularExpression::addOp(char c, stack<BinaryTreeNode*>& op, stack<BinaryTreeNode*>& ch){
    while(c != '(' && op.size() > 0 && get_op_pri(c) <= get_op_pri(op.top()->character) && processOp(op, ch));

    if(c != ')')
        op.push(new BinaryTreeNode(0, 0, c));
    else if(op.empty() || op.top()->character != '(')
        throw "";
    else
        processOp(op, ch);
}

void RegularExpression::recursiveDeleteTree(BinaryTreeNode** r){
    if (*r == NULL)
        return;
    recursiveDeleteTree(&(*r)->leftChild);
    recursiveDeleteTree(&(*r)->rightChild);
    delete (*r);
    *r = NULL;
}

void RegularExpression::postOrder(const BinaryTreeNode *TreeNode){
    if (TreeNode == NULL)
        return;
    postOrder(TreeNode->leftChild);
    postOrder(TreeNode->rightChild);
    postfix_str += TreeNode->character;
    postfix_str += " ";
}

void RegularExpression::calcPos(BinaryTreeNode* cur){
    if(cur->leftChild)
        calcPos(cur->leftChild);
    if(cur->rightChild)
        calcPos(cur->rightChild);


    cur->firstpos.clear();
    cur->lastpos.clear();


    if(!cur->leftChild && !cur->rightChild){ //leaf node
        cur->firstpos.insert(cur);
        cur->lastpos.insert(cur);
    }else if(cur->character == '.'){
        cur->nullable = (cur->leftChild->nullable && cur->rightChild->nullable);

        if(cur->leftChild->nullable)
            set_union(cur->leftChild->firstpos.begin(), cur->leftChild->firstpos.end(),
                      cur->rightChild->firstpos.begin(), cur->rightChild->firstpos.end(),
                      inserter(cur->firstpos, cur->firstpos.begin()));
        else
            cur->firstpos = cur->leftChild->firstpos;

        if(cur->rightChild->nullable)
            set_union(cur->leftChild->lastpos.begin(), cur->leftChild->lastpos.end(),
                      cur->rightChild->lastpos.begin(), cur->rightChild->lastpos.end(),
                      inserter(cur->lastpos, cur->lastpos.begin()));
        else
            cur->lastpos = cur->rightChild->lastpos;


        for(set<BinaryTreeNode*>::iterator it = cur->leftChild->lastpos.begin(); it != cur->leftChild->lastpos.end(); it++){
            set_union((*it)->followpos.begin(), (*it)->followpos.end(),
                      cur->rightChild->firstpos.begin(), cur->rightChild->firstpos.end(),
                      inserter((*it)->followpos, (*it)->followpos.begin()));
        }

    }else if(cur->character == '|'){
        cur->nullable = (cur->leftChild->nullable || cur->rightChild->nullable);
        set_union(cur->leftChild->firstpos.begin(), cur->leftChild->firstpos.end(),
                  cur->rightChild->firstpos.begin(), cur->rightChild->firstpos.end(),
                  inserter(cur->firstpos, cur->firstpos.begin()));
        set_union(cur->leftChild->lastpos.begin(), cur->leftChild->lastpos.end(),
                  cur->rightChild->lastpos.begin(), cur->rightChild->lastpos.end(),
                  inserter(cur->lastpos, cur->lastpos.begin()));

    }else if(cur->character == '*'){
        cur->nullable = true;
        cur->firstpos = cur->leftChild->firstpos;
        cur->lastpos = cur->leftChild->lastpos;

        for(set<BinaryTreeNode*>::iterator it = cur->leftChild->lastpos.begin(); it != cur->leftChild->lastpos.end(); it++){
            set_union((*it)->followpos.begin(), (*it)->followpos.end(),
                      cur->firstpos.begin(), cur->firstpos.end(),
                      inserter((*it)->followpos, (*it)->followpos.begin()));
        }
    }else
        throw;
}

void RegularExpression::makeDFA(){
    dstates_unsigned.insert(root->firstpos);
    set<char> chars;

    while(!dstates_unsigned.empty()){
        set<set<BinaryTreeNode* > >::iterator it = dstates_unsigned.begin();

        for(set<BinaryTreeNode* >::iterator itt =  it->begin(); itt != it->end(); itt++){ //for each input character
            if(chars.find((*itt)->character) != chars.end())
                continue;

            set<BinaryTreeNode* > newstate;
            for(set<BinaryTreeNode* >::iterator itt1 =  it->begin(); itt1 != it->end(); itt1++){ //for each element in set
                if((*itt1)->character != (*itt)->character)
                    continue;
                for(set<BinaryTreeNode* >::iterator itt2 =  (*itt1)->followpos.begin(); itt2 != (*itt1)->followpos.end(); itt2++){
                    //for each element in followpos of each element in set
                    //insert it into our newstate
                    newstate.insert(*itt2);
                }
            }

            chars.insert((*itt)->character);
            if(dstates_signed.find(newstate) == dstates_signed.end()){
                dstates_unsigned.insert(newstate);
            }

            //if()
            dtrans.push_back(DTrans(*it, (*itt)->character, newstate));
        }
        dstates_signed.insert(*it);
        dstates_unsigned.erase(it);
    }
}
